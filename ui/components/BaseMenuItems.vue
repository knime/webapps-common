<script lang="ts">
import type { PropType } from "vue";
import { onBeforeUpdate, ref, toRef } from "vue";
import usePopper from "../composables/usePopper";
import { uniqueId } from "lodash";
import BaseMenuItem from "./BaseMenuItem.vue";
import type { MenuItem } from "./MenuItems.vue";

type ElementTemplateRef = HTMLElement | { $el: HTMLElement };

// eslint-disable-next-line func-style
function isNativeHTMLElement(
  element: ElementTemplateRef,
): element is HTMLElement {
  return !("$el" in element);
}

export default {
  components: { BaseMenuItem },
  props: {
    items: {
      type: Array as PropType<Array<MenuItem>>,
      required: true,
    },
    focusedItemIndex: {
      required: false,
      type: Number as PropType<number | null>,
      default: null,
    },
    menuAriaLabel: {
      type: String,
      required: true,
    },
    /**
     * Identifier for click handler. If left blank an id is generated.
     * NOTE: Autogenerated IDs might break SSR.
     */
    id: {
      default: () => `__BaseMenuItems-${uniqueId()}__`,
      type: String,
    },
    /**
     * Maximum width in px of the menu
     */
    maxMenuWidth: {
      type: Number,
      default: null,
    },
    positionRelativeToElement: {
      type: HTMLElement as PropType<HTMLElement | null>,
      default: null,
    },
  },
  emits: ["item-click", "item-focused", "item-hovered"],
  setup(props) {
    // use composition api refs to be able to sync the index between props.items and the refs to the HTMLElement
    const listItems = ref<ElementTemplateRef[]>([]);
    const positionRelativeToElement = toRef(props, "positionRelativeToElement");
    const listContainer = ref<HTMLElement | null>(null);

    onBeforeUpdate(() => {
      listItems.value = [];
    });

    usePopper(
      {
        popperTarget: listContainer,
        referenceEl: positionRelativeToElement,
      },
      {
        strategy: "fixed",
        placement: "right-start",
        modifiers: [],
      },
    );
    return {
      listContainer,
      listItems,
    };
  },
  computed: {
    useMaxMenuWidth() {
      return Boolean(this.maxMenuWidth);
    },
    enabledItemsIndices() {
      return this.items
        .map((item, index) => ({ item, index }))
        .filter(({ item }) => !item.disabled)
        .map(({ index }) => index);
    },
  },
  watch: {
    focusedItemIndex: {
      immediate: true,
      handler() {
        this.emitItemFocused();
      },
    },
    items: {
      deep: true,
      handler() {
        this.emitItemFocused();
      },
    },
  },
  expose: ["getEnabledListItems", "scrollTo"],
  methods: {
    updateItem(el: HTMLElement, index: number) {
      this.listItems[index] = el;
    },
    getEnabledListItems() {
      const listItems = this.listItems as Array<HTMLLIElement>;

      return listItems
        .map((element, index) => {
          const firstChild = element.children[0] as ElementTemplateRef;

          return {
            element,
            index,
            onClick: isNativeHTMLElement(firstChild)
              ? () => firstChild.click()
              : () => firstChild.$el.click(),
          };
        })
        .filter(({ index }) => this.enabledItemsIndices.includes(index));
    },
    scrollTo(element: HTMLLIElement) {
      const listContainer = this.$refs.listContainer as HTMLUListElement;

      if (
        listContainer &&
        listContainer.scrollHeight > listContainer.clientHeight
      ) {
        const scrollBottom =
          listContainer.clientHeight + listContainer.scrollTop;
        const elementBottom = element.offsetTop + element.offsetHeight;

        if (elementBottom > scrollBottom) {
          listContainer.scrollTop = elementBottom - listContainer.clientHeight;
        } else if (element.offsetTop < listContainer.scrollTop) {
          listContainer.scrollTop = element.offsetTop;
        }
      }
    },
    menuItemId(index: number) {
      return `menu-item-${this.id}-${index}`;
    },
    onPointerEnter(event: Event, item: MenuItem, index: number) {
      this.$emit(
        "item-hovered",
        item.disabled || item.sectionHeadline ? null : item,
        this.id,
        index,
      );
    },
    onItemClick(event: Event, item: MenuItem, id?: string) {
      if (item.disabled || item.sectionHeadline || item.children?.length) {
        return;
      }

      let isButton = !(item.href || item.to);
      if (isButton) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
      }
      this.$emit("item-click", event, item, id);
    },
    emitItemFocused() {
      if (this.focusedItemIndex === null) {
        this.$emit("item-focused", null, null);
        return;
      }
      const index = this.focusedItemIndex as number;
      this.$emit("item-focused", this.menuItemId(index), this.items[index]);
    },
  },
};
</script>

<template>
  <ul
    ref="listContainer"
    :aria-label="menuAriaLabel"
    class="base-menu-items"
    role="menu"
    tabindex="-1"
    @pointerleave="$emit('item-hovered', null, id)"
  >
    <li
      v-for="(item, index) in items"
      :key="index"
      :ref="(el: any) => updateItem(el, index)"
      :data-index="index"
      :class="[{ separator: item.separator }]"
      :style="useMaxMenuWidth ? { 'max-width': `${maxMenuWidth}px` } : {}"
      :title="item.title"
      @click="onItemClick($event, item, id)"
      @pointerenter="onPointerEnter($event, item, index)"
    >
      <slot
        name="item"
        :item="item"
        :index="index"
        :menu-id="id"
        :menu-item-id="menuItemId"
        :max-menu-width="maxMenuWidth"
        :focused-item-index="focusedItemIndex"
      >
        <BaseMenuItem
          :id="menuItemId(index)"
          :item="item"
          :index="index"
          :use-max-menu-width="Boolean(maxMenuWidth)"
          :has-focus="index === focusedItemIndex"
        />
      </slot>
    </li>
  </ul>
</template>

<style lang="postcss" scoped>
.base-menu-items {
  /*
    default to elevation-1, but still allow overriding shadow from outside
    by setting this variable on the component root element's css without having to deep style
   */
  --menu-items-elevation: var(--shadow-elevation-1);

  margin: 5px 0;
  padding: 0;
  background-color: var(--knime-white);
  color: var(--theme-dropdown-foreground-color);
  font-size: 13px;
  line-height: 18px;
  font-weight: 500;
  font-family: var(--theme-text-medium-font-family);
  text-align: left;
  list-style-type: none;
  z-index: var(--z-index-common-menu-items-expanded, 1);
  box-shadow: var(--menu-items-elevation);

  /* Determine offsetTop of child elements correctly when using the scrollTo method */
  position: relative;

  &.expanded {
    display: block;
  }

  &:focus {
    outline: none;
  }

  & li:not(:last-child).separator {
    border-bottom: 1px solid var(--knime-porcelain);
  }
}
</style>
