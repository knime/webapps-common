<script lang="ts">
import type { PropType, FunctionalComponent, SVGAttributes } from 'vue';
import arrowNextIcon from 'webapps-common/ui/assets/img/icons/arrow-next.svg';
import {onBeforeUpdate, ref, toRefs} from 'vue';
import usePopper from '../composables/usePopper';
import { uniqueId } from 'lodash';

export interface MenuItem {
  text: string;
  icon?: FunctionalComponent<SVGAttributes>;
  disabled?: boolean;
  /** shown on menu items on hover */
  title?: string;
  /** for router-links */
  to?: string;
  /** for standard (e.g. external) links */
  href?: string;
  /** adds another styling to the item-font by reducing size and brightening color */
  sectionHeadline?: boolean;
  /** visually emphasizes an item by inverting the color of the item */
  selected?: boolean;
  /** show a separator below the item if it's not the last in the list */
  separator?: boolean;
  /** shown aligned right besides the text */
  hotkeyText?: string;
  /** sub menu */
  children?: Array<MenuItem>
}

type ElementTemplateRef = HTMLElement | { $el: HTMLElement }

// eslint-disable-next-line func-style
function isNativeHTMLElement(element: ElementTemplateRef): element is HTMLElement {
    return !('$el' in element);
}

export default {
    name: 'MenuItemsBase',
    components: {
        arrowNextIcon
    },
    props: {
        items: {
            type: Array as PropType<Array<MenuItem>>,
            required: true
        },
        focusedItemIndex: {
            required: false,
            type: Number as PropType<number|null>,
            default: null
        },
        menuAriaLabel: {
            type: String,
            required: true
        },
        /**
         * Identifier for click handler. If left blank a id is generated.
         * NOTE: Autogenerated IDs might break SSR.
         */
        id: {
            default: () => `__MenuItemsBase-${uniqueId()}__`,
            type: String
        },
        /**
         * Maximum width in px of the menu
         */
        maxMenuWidth: {
            type: Number,
            default: null
        },
        positionRelativeToElement: {
            type: [String, HTMLElement] as PropType<string|null|HTMLElement>,
            default: null
        }
    },
    emits: ['item-click', 'item-focused', 'item-hovered'],
    setup(props) {
        // use composition api refs to be able to sync the index between props.items and the refs to the HTMLElement
        const listItems = ref([]);
        const { positionRelativeToElement } = toRefs(props);
        const listContainer = ref(null);

        onBeforeUpdate(() => {
            listItems.value = [];
        });

        usePopper(
            {
                popperTarget: listContainer,
                referenceEl: positionRelativeToElement
            }, {
                strategy: 'fixed',
                placement: 'right-start',
                modifiers: [
                    {
                        name: 'flip',
                        options: {
                            fallbackPlacements: ['auto-start']
                        }
                    }
                ]
            }
        );
        return {
            listContainer,
            listItems
        };
    },
    data() {
        return {
            openSubmenuItemIndex: -1
        };
    },
    computed: {
        useMaxMenuWidth() {
            return Boolean(this.maxMenuWidth);
        },
        enabledItemsIndices() {
            return this.items.map((item, index) => ({ item, index }))
                .filter(({ item }) => !item.disabled)
                .map(({ index }) => index);
        }
    },
    watch: {
        focusedItemIndex: {
            immediate: true,
            handler() {
                this.emitItemFocused();
            }
        },
        items: {
            deep: true,
            handler() {
                this.emitItemFocused();
            }
        }
    },
    expose: ['getEnabledListItems', 'scrollTo'],
    methods: {
        getEnabledListItems() {
            const listItems = this.listItems as Array<HTMLLIElement>;

            return listItems
                .map((element, index) => {
                    const firstChild = element.firstChild as ElementTemplateRef;

                    return {
                        element,
                        index,
                        onClick: isNativeHTMLElement(firstChild)
                            ? () => firstChild.click()
                            : () => firstChild.$el.click()
                    };
                })
                .filter(({ index }) => this.enabledItemsIndices.includes(index));
        },
        scrollTo(element: HTMLLIElement) {
            const listContainer = this.$refs.listContainer as HTMLUListElement;

            if (listContainer && listContainer.scrollHeight > listContainer.clientHeight) {
                const scrollBottom = listContainer.clientHeight + listContainer.scrollTop;
                const elementBottom = element.offsetTop + element.offsetHeight;

                if (elementBottom > scrollBottom) {
                    listContainer.scrollTop = elementBottom - listContainer.clientHeight;
                } else if (element.offsetTop < listContainer.scrollTop) {
                    listContainer.scrollTop = element.offsetTop;
                }
            }
        },
        linkTagByType(item: MenuItem) {
            if (item.to) {
                return 'nuxt-link';
            } else if (item.href) {
                return 'a';
            } else {
                return 'button';
            }
        },
        menuItemId(index: number) {
            return `menu-item-${this.id}-${index}`;
        },
        updateOpenSubmenuIndex(event, item: MenuItem, index: Number) {
            if (!item.disabled && item.children?.length) {
                this.openSubmenuItemIndex = index;
            }
        },
        onPointerEnter(event: Event, item: MenuItem, index: Number) {
            this.updateOpenSubmenuIndex(event, item, index);
            this.$emit('item-hovered', item.disabled || item.sectionHeadline ? null : item, this.id);
        },
        onPointerLeave() {
            this.openSubmenuItemIndex = -1;
        },
        onItemClick(event: Event, item: MenuItem, id?: string) {
            if (item.disabled || item.sectionHeadline || item.children?.length) {
                return;
            }

            let isButton = !(item.href || item.to);
            if (isButton) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
            }
            this.$emit('item-click', event, item, id);
        },
        emitItemFocused() {
            if (this.focusedItemIndex === null) {
                this.$emit('item-focused', null, null);
                return;
            }
            const index = this.focusedItemIndex as number;
            this.$emit('item-focused', this.menuItemId(index), this.items[index]);
        }
    }
};
</script>

<template>
  <ul
    ref="listContainer"
    :aria-label="menuAriaLabel"
    role="menu"
    tabindex="-1"
    @pointerleave="$emit('item-hovered', null, id)"
  >
    <li
      v-for="(item, index) in items"
      :key="index"
      :ref="el => { listItems[index] = el }"
      :data-index="index"
      :class="[{ separator: item.separator }]"
      :style="useMaxMenuWidth ? { 'max-width': `${maxMenuWidth}px` } : {}"
      :title="item.title"
      @click="onItemClick($event, item, id)"
      @pointerenter="onPointerEnter($event, item, index)"
      @pointerleave="onPointerLeave"
    >
      <Component
        :is="linkTagByType(item)"
        :id="menuItemId(index)"
        :ref="`listItemComponent--${index}`"
        tabindex="-1"
        :class="['list-item', item.sectionHeadline ? 'section-headline' : 'clickable-item', {
          disabled: item.disabled, selected: item.selected, focused: index === focusedItemIndex }]"
        :to="item.to || null"
        :href="item.href || null"
      >
        <Component
          :is="item.icon"
          v-if="item.icon"
          class="item-icon"
        />
        <div class="label">
          <span :class="['text', { truncate: useMaxMenuWidth }]">
            {{ item.text }}
          </span>
          <span
            v-if="item.hotkeyText"
            class="hotkey"
          >{{ item.hotkeyText }}</span>
          <span
            v-if="item.children && item.children.length"
            class="sub-menu-indicator"
          >
            <arrowNextIcon class="icon" />
            <MenuItemsBase
              v-if="openSubmenuItemIndex === index"
              :id="`${id}__${item.name}`"
              class="menu-items-level"
              :menu-aria-label="`${item.text} sub menu`"
              :items="item.children"
              :max-menu-width="maxMenuWidth"
              :position-relative-to-element="$refs[`listItemComponent--${index}`][0]"
              @item-click="(...args) => $emit('item-click', ...args)"
              @item-hovered="(...args) => $emit('item-hovered', ...args)"
              @item-focused="(...args) => $emit('item-focused', ...args)"
            />
          </span>
        </div>
      </Component>
    </li>
  </ul>
</template>

<style lang="postcss" scoped>
ul {
  margin: 5px 0;
  padding: 0;
  background-color: var(--knime-white);
  color: var(--theme-dropdown-foreground-color);
  font-size: 13px;
  line-height: 18px;
  font-weight: 500;
  font-family: var(--theme-text-medium-font-family);
  text-align: left;
  list-style-type: none;
  z-index: var(--z-index-common-menu-items-expanded, 1);

  /* Determine offsetTop of child elements correctly when using the scrollTo method */
  position: relative;

  &.expanded {
    display: block;
  }

  &:focus {
    outline: none;
  }

  & li:not(:last-child).separator {
    border-bottom: 1px solid var(--knime-porcelain);
  }

  & .list-item {
    border: none;
    background: none;
    width: 100%;
    padding: 6px 13px;

    & .sub-menu-indicator {
      & .icon {
        width: 11px;
        height: 11px;
        stroke-width: calc(32px / 11);
        pointer-events: none;
        stroke: var(--theme-dropdown-foreground-color);
      }
    }

    /* <button> does not inherit font-weight from ul in chrome */
    font-weight: 500;
    display: flex;
    text-decoration: none;
    white-space: nowrap;
    color: var(--theme-text-normal-color);

    &.clickable-item {
      cursor: pointer;

      &.disabled {
        opacity: 0.5;
        cursor: default;
        pointer-events: none;
      }

      & .item-icon {
        stroke: var(--theme-dropdown-foreground-color);
        stroke-width: calc(32px / 18);
        width: 18px;
        height: 18px;
        margin-right: 7px;
      }

      &.selected {
        background-color: var(--theme-dropdown-foreground-color);
        color: var(--theme-dropdown-background-color); /* background and foreground are switched on selection */

        & .item-icon {
          stroke: var(--theme-dropdown-background-color);
        }
      }

      & .label {
        display: flex;
        text-align: left;
        width: 100%;

        & .text {
          flex-shrink: 1;
          flex-basis: 100%;

          &.truncate {
            overflow: hidden;
            text-overflow: ellipsis;
          }
        }

        & .hotkey {
          margin-left: 40px;
        }
      }

      &:hover {
        outline: none;
        background-color: var(--theme-dropdown-background-color-hover);
        color: var(--theme-dropdown-foreground-color-hover);

        & .item-icon {
          stroke: var(--theme-dropdown-foreground-color-hover);

          & .text {
            stroke: var(--theme-dropdown-foreground-color-hover);
          }
        }
      }

      &.focused {
        outline: none;
        background-color: var(--theme-dropdown-background-color-focus);
        color: var(--theme-dropdown-foreground-color-focus);

        & .item-icon {
          stroke: var(--theme-dropdown-foreground-color-focus);

          & .text {
            stroke: var(--theme-dropdown-foreground-color-focus);
          }
        }
      }
    }

    &.section-headline {
      color: var(--knime-stone);
      padding-top: 13px;
      pointer-events: none;
      height: 30px;
      font-size: 10px;
      line-height: 15px;
      display: flex;
      align-items: center;

      &:hover,
      &:focus,
      &:active {
        outline: none;
      }
    }
  }
}
</style>
